{
  "hash": "3b289b73ed59acfbed0974e2a164355a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Thoughts on Positron Assistant\"\ndescription: \"Increasing productivity as an analyst\"\nauthor:\n  - name: Raymond Hunter \n    url: <https://ramhunte.github.io/\ndate: 10-30-2025\n# bibliography: references.bib\ncitation: \n  url: <https://ramhunte.github.io/blogs/positron_assistant/\n# bibliography: references.bib\nimage: images/\ncategories: [LLM] # self-defined categories\nformat: \n  html: \n    # code-fold: show \n    code-copy: true \n    code-summary: \"code\" \n    code-line-numbers: false \n    code-tools: true \n    code-block-border-left: true\n    # embed-resources: true\n    warning: false\n    message: false\ntoc: true\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\nI was pretty slow to migrate over to [Positron](https://positron.posit.co/), Posit's new  integrated development environment (IDE) that was made to more natively support Python and accomdate data scientists outside of the R world. I don't use much Python that much, so I didn't bother making the switch at first. Researchers and academics aren't always the first to hop on emerging tools and products... or even the second. My attachment to RStudio's classic and reliable graphical user interface (GUI) kept me skeptical about breaking the status quo and adopting the adolecent product. Why fix something if it's not broken? Well, after a curious introduction to the new software, I am more than stoked I made the switch as it has a lot more to offer R users than just Python integration.\n\nI was so inspired by my (initially reluctant) switch to Positron that I felt it would be helpful to write a blog up to convince fellow data scientists and analysts why it is worthwhile to checkout. Positron offers many features that give it a leg up over its older sibling, RStudio. It is tailored specifically to the needs of data scientists and analysts, providing what we need where we need it. I won't go into detail on all of its bells and whistles in this blog, but I will mention a few of the key feautures that stood out to me:\n\n- Improved data frame/variable exploration (interactive filtering,  sorting, etc.)\n- Better point-and-click integration with GitHub commands\n- Aesthetic source control and commit history layout \n- Multi-language support (R, Python, etc.)\n\nI could go on and on about this, but that is not what this post is about. It is about the one feature that drew me in like a moth to a flame. The one feature that showed me how my day to day was about to forever change. It is about [*Positron Assistant*](https://positron.posit.co/assistant.html).\n\n\n<br><br>\n\n\n## Positron assistant \n\n![](images/positron-assistant-blue.svg){width=30% fig-align=\"center\" fig-alt=\"Positron Assistant logo\"}\n\nPositron Assistant is \"***an AI client that provides LLM integration within Positron, both for chat and for inline completions.***\" - [Posit](https://posit.co/). It is Posit's native AI coding assistant that can be powered by either Anthropic Claude models or various other large language models (LLMs) supported in GitHub Copilot (as of 10-30-2025). But why is Positron Assistant any better for data scientists and analysts compared to web interfaces? Code completion and LLM chatbots are not new concepts afterall. The key is that Positron Assistant brings LLM chats directly into the IDE which reduces the friction of copy-paste and also incorporates your code base and environment context (files, variables, data frames, system version, etc.) into its understanding of your requests, giving you more specific results. More importantly, it can function as an *AI Agent*, meaning it can perform tasks on behalf of the user by executing code and iterating over errors to give you the best results. It is honeslty a bit scary. \n\n\n::: {.callout-note}\n\n## Install and Enable\n\n1. [Download and install Positron](https://positron.posit.co/install.html)\n\n2. [Enable Positron Assistant](https://positron.posit.co/assistant.html)\n\nYou will need either an API key from Anthropic (paid) or a GitHub account (free tier available) to use Positron Assistant. GitHub Copilot has both code completion and chat modes available while Anthropic Claude currently only has chat. I use GtHub Copilot in this demonstration.\n:::\n\n<br><br>\n\n## Functionalities\n\nPositron Assistant offers two different main functionalities -  **chat** and **code completion**. Chat is the core functionality that allows you to ask questions and talk to the LLM (either in the Chat Pane or Inline), similarily to what you would see on a web interface but it is integrated into Positron. Code completion suggests code and annotations for you as you are typing it out. It is basically an autocomplete for code that tries to finish your lines for you. It has been available in GitHub Copilot for quite some time. \n\n<br> \n\n::: {.grid}\n\n::: {.g-col-6}\n\n### Chat {style=\"text-align: center;\"}\n\n----------\n\n\nThere are currently 3 different chat modes available in Positron Assistant, or 3 different ways in which you can expect the model to assist you. Posit defines the modes as the following: \n\n - **Ask**: Use this mode to ask questions, get help with debugging, or request code generation. This is the default mode when you open the chat.\n\n - **Edit**: Use this mode to make code changes with the model’s help. The model will suggest code changes based on your prompts, and you can apply those changes to your code.\n\n - **Agent**: Use this mode if you’d like Positron Assistant to determine the steps needed for your request and autonomously carry out the work. On your behalf, Positron Assistant can execute code in the Console, create and modify files, and identify the next steps based on the results of the previous steps.\n\n:::\n\n::: {.g-col-6}\n\n### Code completion  {style=\"text-align: center;\"}\n\n----------\n\n\n\nIf using GitHub Copilot you will be provided with code completion. It has been available for quite a while and simply offers suggestions on what to insert next based.\n\n:::\n:::\n\n::: {.callout-tip}\nYou can provide Chat mode with additional conext (files, variables, R session, etc.) by clicking on the *Add Context* button in the Chat pane to give more specific detail in your requests  \n:::\n\n\n<br> \n<br> \n\n## Examples\n\nThese different options and modes can seem a little bit confusing without seeing them in action. Let's run through a simple scenario in which you would use each of the modes in Chat.\n\n### Ask \nI gave Positron Assistant a very simple task in *Ask* mode. I requested the following: \n\n > *\"Generate some exploratory data analysis figures of the mtcars dataset with ggplot2\"*\n\nIt responded with some nice R code which I could run directly in the chat before adding in my R script. It included a few different plots that were saved as variables and stitched together to make a `{patchwork}` plot shown in the Plots pane. \n\n\n![](images/chat_ask.png){width=90% fig-align=\"center\" fig-alt=\"mtcars EDA plots generated by Positron Assistant\"}\n\n\nHere is the code it generated and which could be easily transferred into your script or notebook:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Create visualization of relationships between mpg and key variables\np1 <- ggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(title = \"MPG vs Weight\", x = \"Weight (1000 lbs)\", y = \"Miles per Gallon\")\n\np2 <- ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +\n  geom_boxplot(fill = \"lightblue\") +\n  labs(\n    title = \"MPG by Cylinder Count\",\n    x = \"Number of Cylinders\",\n    y = \"Miles per Gallon\"\n  )\n\np3 <- ggplot(mtcars, aes(x = hp, y = mpg, color = factor(cyl))) +\n  geom_point() +\n  labs(\n    title = \"MPG vs Horsepower by Cylinders\",\n    x = \"Horsepower\",\n    y = \"Miles per Gallon\",\n    color = \"Cylinders\"\n  )\n\n# Arrange plots in a grid\nlibrary(patchwork)\np1 +\n  p2 +\n  p3 +\n  plot_layout(ncol = 2) +\n  plot_annotation(\n    title = \"Fuel Efficiency Relationships in mtcars Dataset\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-tip}\nIf you are asking an R Shiny specific question, start your message with `@Shiny` to leverage Positron Assitant's Shiny chat participant which is fine tuned for all things Shiny\n:::\n\nSo far so good! I gave it a well known R dataset and an easy task. I also could have done this in ChatGPT for free and copied and pasted it into my code too though, so it isn't a home run yet. \n\nLet's say I wanted to change the boxplot fill color to green instead. It would also be nice if the final `ggplot2` object could be saved as its own value and exported as a PNG. We could use *Ask* mode to do this, but *Ask* mode can be a little general at times and focuses more on initial code generation and big picture questions. Because we are trying to fix a small, specific piece of a code already genrated, it would be more appropriate to use the *Edit* mode to get more desirable results. *Edit* mode focuses on making accute changes to code already in the code base.\n\n<br> \n\n### Edit\n\nI gave the chat the follwoig prompt in *Edit* mode:\n\n> *\"Write me code that will change the boxplot fill color to green and save the final plot as a PNG file named mtcars_eda.png.\"*\n\n\nThe nice this about the results in *Edit* mode is that it only showed me the pieces of code it modified. The results appear to be more focused on the specific changes and less on the general structure like what you get in *Ask* mode. \n\n\n::: {.cell run='false'}\n\n```{.r .cell-code}\n# Change boxplot fill color to green\np2 <- ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +\n  geom_boxplot(fill = \"green\") +\n  labs(\n    title = \"MPG by Cylinder Count\",\n    x = \"Number of Cylinders\",\n    y = \"Miles per Gallon\"\n  )\n\n# Create and save the combined plot\ncombined_plot <- p1 +\n  p2 +\n  p3 +\n  plot_layout(ncol = 2) +\n  plot_annotation(title = \"Fuel Efficiency Relationships in mtcars Dataset\")\n\n# Save as PNG\nggsave(\"mtcars_eda.png\", combined_plot, width = 12, height = 8)\n```\n:::\n\n\nIt successfully gave me *only* the code I needed to change the color and save a PNG to my working directory like I asked it to.  \n\n![](images/chat_edit.png){width=70% fig-align=\"center\" fig-alt=\"updated mtcars EDA plots in my directory\"}\n\nSimilarily to *Ask* mode, I could have also done this in ChatGPT for free. However, the advantage here is that it has the additional context of my R environment and I don't need to copy and paste code back and forth to a website which gives me more accurate results. Let's take a look at where the real power of Positron Assistant shines. \n\n<br>\n\n### Agent\n\nFinally for the scary part... *Agent* mode essentially lets Positron Assistant take over your IDE and perform tasks by itself upon your approval. *Agent* mode acts like a highly efficient coworker who will carry out tasks you ask it to and take steps it sees as necessary to get you the results. It feels really weird and risky to let it take the reigns like that, but I tried it out anyway. I gave it the following prompt which is more specific and complex than the previous two:\n\n![](images/chat_agent_response.png){width=70% fig-align=\"center\" fig-alt=\"Positron Assistant Agent mode response\"} \n\nIt then responded:\n\n> *\"I'll create a Quarto report that explores some key questions about the mtcars dataset. Here's the content:\"*\n\n\nI then watched it generate appropriate code and text inside a file called `mtcars_analysis.qmd` that *it* created. To be fair, it asked me the following: \n\n> *\"I'll create a new task to save this as 'mtcars_report.qmd' and render it. You can then open the rendered HTML file to view the complete report. Would you like me to save this file and render it for you?\"*\n\nAfter I gave it the thumbs up, it created the quarto file in my working directory and rendered the it as an HTML file. \n\n!{}(images/html.png){width=90% fig-align=\"center\" fig-alt=\"Rendered mtcars analysis report\"}\n\nPretty impressive, right? Positron Assitant can be very powerful, especially when used in *Agent* mode. \n\n<br><br>\n\n## Databot \n![Databot](images/databot-logo_positronblue.svg){width=30% fig-align=\"center\" fig-alt=\"Positron Assistant logo\"}\n\nDatabot is an experimental feautre of Positron Assistant that specializes in data analysis tasks such as data cleaning, visualization, and explroation. I see it as a more *specialized* copilot that helps you crack open you data to get more insights faster. While Positron Assitant *Ask* mode can also do this for us as we just saw, databot would be more thorough in related tasks. Databot is currently only supported with a paid Anthropic Claude API key, so I chose to not get demo it here as it would not be accessible to everyone. However, I encourage you to try it out if you have a paid Anthropic API key as is highly rewarding.\n\n\n::: {.callout-note}\n**Installation:** Make sure you have Positron Assistant enabled to use Databot. Install Databot by choosing the Extension view from the activity bar on the left or run `Ctrl-Shift-X` to open it. Search for *Databot* and install it. Once installed, open the settings icon and acknowledge *Databot: Research Preview Acknowldgement*. Read more about Databot [here](https://positron.posit.co/databot.html).\n:::\n\n\n## Final thoughts\n\nOverall, I am feeling both excited and conflicted about the integaration of LLMs into IDEs like Positron Assistant. They are etremely powerful tools that can greatly increase efficiency, productivity. You can get code debugged and generated remarkably quickly, generate reports autonomously in *Agent* mode, and gain new insights into improving your analytical pipelines. \n\nHowever, I do see these tools pushing analysts to becoming vibe-coders where we end up relying heavily on LLMs to execute our work. So much of the learning and joy as an analyst comes from looking deep on stack overflow and GitHub for solutions. It teaches you how to think like a programmer, and I am afraid that reliance on these chatbots like Positron Assistant will change the way we work. I think that we just have to move cautiously and be caustious about how we integrate these tools into our workflow. \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}